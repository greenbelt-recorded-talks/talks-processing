{% extends 'base.html' %}

{% block content %}

<h1 class="uk-heading-line uk-text-center"><span>Talks Front Desk</span></h1>

<div class="uk-card uk-card-body uk-card-default">

<h1> Front Desk </h1>

The talks below are the ones that have started, but that RAW files haven't yet been uploaded for.

If you have a recorder notes photo, upload this first, as the talk will disappear from this list when the RAW file is uploaded

<table>
<tr>
	<th>Talk ID</th>
        <th>Day</th>
	<th>Time</th>
        <th>Venue</th>
        <th>Speaker</th>
        <th>Title</th>
	<th>RAW file</th>
	<th>Recorder Notes Photo</th>
</tr>
{% for talk in talks_to_upload %}
{% if talk.id not in raw_talks_available %}
<tr>
	<td>{{ talk.id }}</td>
        <td>{{ talk.day }}</td>
        <td>{{ talk.start_time.strftime("%H:%M") }}</td>
        <td>{{ talk.venue }}</td>
        <td>{{ talk.speaker }}</td>
        <td>{{ talk.title }}</td>
	<td>
		<div class="upload-warning-{{ talk.id }}" style="display: none; margin-bottom: 8px;">
			<div class="uk-alert uk-alert-warning" uk-alert>
				<p><strong>⚠️ Warning:</strong> <span class="warning-message"></span></p>
			</div>
		</div>
		<form class="upload-form" data-talk-id="{{ talk.id }}" data-file-type="raw">
                	<input name="file" type="file" accept=".mp3,.mp4,.mov,.avi,.mkv,.m4a,.wav" required>
                        <button type="submit" class="uk-button uk-button-primary">
                            <span class="button-text">Upload</span>
                            <div uk-spinner="ratio: 0.5" class="upload-spinner" style="display: none;"></div>
                        </button>
                </form>
                <div class="upload-status" style="margin-top: 8px;"></div>
                <small class="uk-text-muted">Supports audio (MP3, WAV, M4A) and video files (MP4, MOV, AVI, MKV)</small>
	</td>
	<td>
                <form method=post enctype=multipart/form-data name=upload_photo action=uploadrecordernotes>
                        <input name=file type=file id=file accept=".jpg">
                        <input name=talk_id type=hidden value="{{talk.id}}">
                        <button>Upload</button>
                </form>
        </td>
	</form>
</tr>
<tr>
	<td colspan="8"><hr /></td>
</tr>
{% endif %}
{% endfor %}
</table>

</div>

{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Check for ongoing uploads when page loads
    checkOngoingUploads();
    
    // Check for ongoing uploads every 30 seconds
    setInterval(checkOngoingUploads, 30000);
    
    // Handle upload form submissions
    document.querySelectorAll('.upload-form').forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const fileInput = this.querySelector('input[type="file"]');
            const button = this.querySelector('button');
            const buttonText = button.querySelector('.button-text');
            const spinner = button.querySelector('.upload-spinner');
            const statusDiv = this.parentNode.querySelector('.upload-status');
            const talkId = this.dataset.talkId;
            const fileType = this.dataset.fileType;
            
            // Check if file is selected
            if (!fileInput.files.length) {
                showStatus(statusDiv, 'Please select a file', 'error');
                return;
            }
            
            // Show spinner and disable button
            buttonText.style.display = 'none';
            spinner.style.display = 'inline-block';
            button.disabled = true;
            statusDiv.innerHTML = '';
            
            // Create FormData
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            formData.append('talk_id', talkId);
            formData.append('file_type', fileType);
            
            // Check file size to decide upload method
            const file = fileInput.files[0];
            const fileSize = file.size;
            const fileName = file.name.toLowerCase();
            const isLargeFile = fileSize > 250 * 1024 * 1024; // 250MB threshold
            const isVideo = fileName.endsWith('.mp4') || fileName.endsWith('.mov') || 
                           fileName.endsWith('.avi') || fileName.endsWith('.mkv');
            
            if (isLargeFile || isVideo) {
                // Use chunked upload for large files or videos
                uploadFileChunked(file, talkId, fileType, statusDiv, fileInput, this, button, buttonText, spinner);
            } else {
                // Use regular upload for small files
                uploadFileRegular(formData, talkId, statusDiv, fileInput, this, button, buttonText, spinner);
            }
        });
    });
    
    function uploadFileRegular(formData, talkId, statusDiv, fileInput, form, button, buttonText, spinner) {
        // Regular upload for small files
        fetch('/uploadtalk_ajax', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showStatus(statusDiv, data.message, 'success');
                
                // Check if this was a video file upload that started background processing
                const fileName = fileInput.files[0].name.toLowerCase();
                const isVideo = fileName.endsWith('.mp4') || fileName.endsWith('.mov') || 
                               fileName.endsWith('.avi') || fileName.endsWith('.mkv');
                
                if (isVideo && data.message.includes('background')) {
                    // Start polling for video processing status
                    startVideoStatusPolling(talkId, statusDiv);
                } else {
                    // Clear the file input for non-video uploads
                    fileInput.value = '';
                    // Hide the form since file is uploaded
                    setTimeout(() => {
                        form.style.display = 'none';
                        statusDiv.innerHTML = '<span class="uk-text-success">✓ File uploaded</span>';
                    }, 2000);
                }
            } else {
                showStatus(statusDiv, data.error, 'error');
            }
        })
        .catch(error => {
            console.error('Upload error:', error);
            showStatus(statusDiv, 'Upload failed. Please try again.', 'error');
        })
        .finally(() => {
            // Hide spinner and re-enable button
            buttonText.style.display = 'inline';
            spinner.style.display = 'none';
            button.disabled = false;
        });
    }
    
    
    function showStatus(element, message, type) {
        let alertClass;
        switch(type) {
            case 'error':
                alertClass = 'uk-alert-danger';
                break;
            case 'warning':
                alertClass = 'uk-alert-warning';
                break;
            case 'info':
                alertClass = 'uk-alert-primary';
                break;
            case 'success':
            default:
                alertClass = 'uk-alert-success';
                break;
        }
        
        element.innerHTML = `
            <div class="uk-alert ${alertClass}" uk-alert>
                <a class="uk-alert-close" uk-close></a>
                <p>${message}</p>
            </div>
        `;
    }
    
    function startVideoStatusPolling(talkId, statusDiv) {
        let pollCount = 0;
        const maxPolls = 720; // Poll for up to 1 hour (5 second intervals)
        
        const pollStatus = () => {
            pollCount++;
            
            if (pollCount > maxPolls) {
                showStatus(statusDiv, 'Video processing is taking longer than expected. Please check manually.', 'warning');
                return;
            }
            
            fetch(`/check_video_status?talk_id=${talkId}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.success) {
                        showStatus(statusDiv, `Status check failed: ${data.error}`, 'error');
                        return;
                    }
                    
                    switch(data.status) {
                        case 'processing':
                            showStatus(statusDiv, 
                                `${data.message} (${Math.floor(pollCount * 5 / 60)}m ${(pollCount * 5) % 60}s)`, 
                                'info'
                            );
                            setTimeout(pollStatus, 5000); // Poll every 5 seconds
                            break;
                            
                        case 'completed':
                            showStatus(statusDiv, '✓ Video uploaded and audio extracted successfully!', 'success');
                            // Hide the upload form
                            setTimeout(() => {
                                const form = statusDiv.parentNode.querySelector('.upload-form');
                                if (form) {
                                    form.style.display = 'none';
                                    statusDiv.innerHTML = '<span class="uk-text-success">✓ Video processed</span>';
                                }
                            }, 2000);
                            break;
                            
                        case 'error':
                            showStatus(statusDiv, `Video processing failed: ${data.message}`, 'error');
                            break;
                            
                        case 'not_started':
                            showStatus(statusDiv, 'Video processing not yet started. Please wait...', 'info');
                            setTimeout(pollStatus, 5000);
                            break;
                            
                        default:
                            showStatus(statusDiv, `Unknown status: ${data.status}`, 'warning');
                            break;
                    }
                })
                .catch(error => {
                    console.error('Status check error:', error);
                    showStatus(statusDiv, 'Unable to check processing status. Please refresh the page.', 'error');
                });
        };
        
        // Start polling after a brief delay
        setTimeout(pollStatus, 2000);
    }
    
    function uploadFileChunked(file, talkId, fileType, statusDiv, fileInput, form, button, buttonText, spinner) {
        const chunkSize = 500 * 1024 * 1024; // 500MB chunks
        const totalChunks = Math.ceil(file.size / chunkSize);
        let uploadSessionId = null;
        let chunksUploaded = 0;
        
        console.log(`Starting chunked upload: ${file.name}, ${file.size} bytes, ${totalChunks} chunks`);
        
        // Step 1: Initialize upload
        const initData = new FormData();
        initData.append('talk_id', talkId);
        initData.append('file_type', fileType);
        initData.append('file_name', file.name);
        initData.append('file_size', file.size);
        initData.append('total_chunks', totalChunks);
        
        showStatus(statusDiv, 'Initializing chunked upload...', 'info');
        
        fetch('/init_chunked_upload', {
            method: 'POST',
            body: initData
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                throw new Error(data.error);
            }
            
            uploadSessionId = data.upload_session_id;
            const existingChunks = data.existing_chunks || [];
            chunksUploaded = existingChunks.length;
            
            if (existingChunks.length > 0) {
                showStatus(statusDiv, `Resuming upload: ${existingChunks.length}/${totalChunks} chunks already uploaded`, 'info');
            }
            
            // Step 2: Upload chunks
            uploadChunksSequentially(file, uploadSessionId, chunkSize, totalChunks, existingChunks, 
                                   talkId, statusDiv, fileInput, form, button, buttonText, spinner);
        })
        .catch(error => {
            console.error('Failed to initialize chunked upload:', error);
            showStatus(statusDiv, `Failed to start upload: ${error.message}`, 'error');
            // Re-enable button
            buttonText.style.display = 'inline';
            spinner.style.display = 'none';
            button.disabled = false;
        });
    }
    
    async function uploadChunksSequentially(file, uploadSessionId, chunkSize, totalChunks, existingChunks, 
                                          talkId, statusDiv, fileInput, form, button, buttonText, spinner) {
        try {
            for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {
                // Skip chunks that were already uploaded
                if (existingChunks.includes(chunkNumber)) {
                    updateChunkProgress(chunkNumber + 1, totalChunks, statusDiv);
                    continue;
                }
                
                const start = chunkNumber * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                const chunk = file.slice(start, end);
                
                const chunkData = new FormData();
                chunkData.append('upload_session_id', uploadSessionId);
                chunkData.append('chunk_number', chunkNumber);
                chunkData.append('chunk', chunk);
                
                showStatus(statusDiv, `Uploading chunk ${chunkNumber + 1}/${totalChunks} (${formatBytes(chunk.size)})...`, 'info');
                
                const response = await fetch('/upload_chunk', {
                    method: 'POST',
                    body: chunkData
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error);
                }
                
                updateChunkProgress(result.chunks_received, totalChunks, statusDiv);
                
                // Small delay to prevent overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Step 3: Complete upload
            completeChunkedUpload(uploadSessionId, talkId, statusDiv, fileInput, form, button, buttonText, spinner);
            
        } catch (error) {
            console.error('Error uploading chunks:', error);
            showStatus(statusDiv, `Upload failed: ${error.message}`, 'error');
            // Re-enable button
            buttonText.style.display = 'inline';
            spinner.style.display = 'none';
            button.disabled = false;
        }
    }
    
    function completeChunkedUpload(uploadSessionId, talkId, statusDiv, fileInput, form, button, buttonText, spinner) {
        const completeData = new FormData();
        completeData.append('upload_session_id', uploadSessionId);
        
        showStatus(statusDiv, 'Reassembling file...', 'info');
        
        fetch('/complete_chunked_upload', {
            method: 'POST',
            body: completeData
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                throw new Error(data.error);
            }
            
            showStatus(statusDiv, '✓ Upload completed successfully!', 'success');
            
            // Check if this started video processing
            const fileName = fileInput.files[0].name.toLowerCase();
            const isVideo = fileName.endsWith('.mp4') || fileName.endsWith('.mov') || 
                           fileName.endsWith('.avi') || fileName.endsWith('.mkv');
            
            if (isVideo) {
                showStatus(statusDiv, '✓ Upload completed. Starting video processing...', 'success');
                // Start polling for video processing status
                setTimeout(() => startVideoStatusPolling(talkId, statusDiv), 2000);
            } else {
                // Clear the file input and hide form for non-video uploads
                fileInput.value = '';
                setTimeout(() => {
                    form.style.display = 'none';
                    statusDiv.innerHTML = '<span class="uk-text-success">✓ File uploaded</span>';
                }, 2000);
            }
            
            // Re-enable button
            buttonText.style.display = 'inline';
            spinner.style.display = 'none';
            button.disabled = false;
        })
        .catch(error => {
            console.error('Failed to complete upload:', error);
            showStatus(statusDiv, `Failed to complete upload: ${error.message}`, 'error');
            // Re-enable button
            buttonText.style.display = 'inline';
            spinner.style.display = 'none';
            button.disabled = false;
        });
    }
    
    function updateChunkProgress(chunksCompleted, totalChunks, statusDiv) {
        const percentage = Math.round((chunksCompleted / totalChunks) * 100);
        showStatus(statusDiv, `Upload progress: ${chunksCompleted}/${totalChunks} chunks (${percentage}%)`, 'info');
    }
    
    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    function checkOngoingUploads() {
        console.log('Checking for ongoing uploads...');
        fetch('/check_ongoing_uploads')
            .then(response => response.json())
            .then(data => {
                console.log('Ongoing uploads response:', data);
                if (data.success) {
                    // Clear all existing warnings first
                    document.querySelectorAll('[class*="upload-warning-"]').forEach(warning => {
                        warning.style.display = 'none';
                    });
                    
                    // Show warnings for ongoing uploads
                    console.log('Processing ongoing uploads:', data.ongoing_uploads);
                    Object.entries(data.ongoing_uploads).forEach(([key, upload]) => {
                        console.log(`Processing upload ${key}:`, upload);
                        if (upload.type === 'video_processing' && upload.talk_id) {
                            console.log(`Showing video processing warning for talk ${upload.talk_id}`);
                            showUploadWarning(upload.talk_id, 'Video processing is currently in progress for this talk. Uploading a new file may overwrite the current work.');
                        } else if (upload.type === 'chunked_upload' && upload.talk_id) {
                            console.log(`Showing chunked upload warning for talk ${upload.talk_id}`);
                            showUploadWarning(upload.talk_id, `Chunked upload in progress: ${upload.progress_percent}% complete (${upload.chunks_received}/${upload.total_chunks} chunks). Please wait for it to complete.`);
                        } else if (upload.type === 'upload') {
                            if (upload.talk_id) {
                                // Show specific warning for the talk being uploaded
                                if (upload.status === 'uploading') {
                                    console.log(`Showing upload warning for talk ${upload.talk_id}`);
                                    showUploadWarning(upload.talk_id, 'A file upload is currently in progress for this talk. Please wait for it to complete.');
                                } else if (upload.status === 'processing') {
                                    console.log(`Showing processing warning for talk ${upload.talk_id}`);
                                    showUploadWarning(upload.talk_id, 'File upload completed, processing in progress for this talk. Uploading another file may overwrite the current work.');
                                }
                            } else {
                                console.log('Showing general upload warning on all talks');
                                // For uploads without specific talk ID, show warning on all talks
                                document.querySelectorAll('.upload-form').forEach(form => {
                                    const talkId = form.dataset.talkId;
                                    showUploadWarning(talkId, 'Another file upload is currently in progress. Please wait for it to complete to avoid conflicts.');
                                });
                            }
                        }
                    });
                    
                    // If there are any ongoing uploads, update the page title
                    if (data.count > 0) {
                        if (!document.title.includes('⏳')) {
                            document.title = '⏳ ' + document.title;
                        }
                    } else {
                        document.title = document.title.replace('⏳ ', '');
                    }
                }
            })
            .catch(error => {
                console.error('Error checking ongoing uploads:', error);
                // Don't show error to user as this is a background check
            });
    }
    
    function showUploadWarning(talkId, message) {
        console.log(`Attempting to show warning for talk ${talkId}: ${message}`);
        const warningDiv = document.querySelector(`.upload-warning-${talkId}`);
        console.log(`Warning div found:`, warningDiv);
        if (warningDiv) {
            const messageSpan = warningDiv.querySelector('.warning-message');
            console.log(`Message span found:`, messageSpan);
            if (messageSpan) {
                messageSpan.textContent = message;
                warningDiv.style.display = 'block';
                console.log(`Warning displayed for talk ${talkId}`);
            }
        } else {
            console.log(`No warning div found for talk ${talkId}`);
        }
    }
});
</script>
{% endblock %}


